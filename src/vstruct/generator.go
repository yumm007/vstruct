package vstruct

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

type generator struct {
	buf *bytes.Buffer
}

func (g *generator) writeHeader() {
	fmt.Fprintf(g.buf, "import (\n")
	fmt.Fprintf(g.buf, "\t\"bytes\"\n")
	fmt.Fprintf(g.buf, "\t\"encoding/binary\"\n")
	fmt.Fprintf(g.buf, ")\n\n")
}

func (g *generator) filedEncodeGenerate(f *Field, r string, pre string) {
	defer func() {
		fmt.Fprintf(g.buf, "%s\t\treturn err\n", pre)
		fmt.Fprintf(g.buf, "%s\t}\n", pre)
	}()

	if f.Tag != nil {
		if f.Tag.Refer != nil {
			fmt.Fprintf(g.buf, "%s\tif err := %s.%s[i].encodeToBuffer(buf); err != nil {\n", pre, r, f.Name)
			return
		}
	}

	fmt.Fprintf(g.buf, "%s\tif err := binary.Write(buf, binary.LittleEndian, &%s.%s); err != nil {\n", pre, r, f.Name)
}

func (g *generator) structEncodeGenerate(st *Struct) {
	receiver := strings.ToLower(string(st.Name[0]))

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)Encode() ([]byte, error) {\n", receiver, st.Name)
	fmt.Fprintf(g.buf, "\tbuf := new(bytes.Buffer)\n")
	fmt.Fprintf(g.buf, "\tif err := %s.encodeToBuffer(buf); err != nil {\n", receiver)
	fmt.Fprintf(g.buf, "\t\treturn nil, err\n")
	fmt.Fprintf(g.buf, "\t}\n")
	fmt.Fprintf(g.buf, "\treturn buf.Bytes(), nil\n")
	fmt.Fprintf(g.buf, "}\n")

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)encodeToBuffer(buf *bytes.Buffer) error {\n", receiver, st.Name)

	for _, f := range st.Fields {
		if f.Tag != nil {
			if f.Tag.Repeat != nil {
				fmt.Fprintf(g.buf, "\tfor i := 0; i < int(%s.%s); i++ {\n", receiver, *f.Tag.Repeat)
				g.filedEncodeGenerate(f, receiver, "\t")
				fmt.Fprintf(g.buf, "\t}\n")
				continue
			}
		}

		g.filedEncodeGenerate(f, receiver, "")
	}

	fmt.Fprintf(g.buf, "\n\treturn nil\n")
	fmt.Fprintf(g.buf, "}\n")
}

func (g *generator) filedDecodeGenerate(f *Field, r string, pre string) {
	defer func() {
		fmt.Fprintf(g.buf, "%s\t\treturn err\n", pre)
		fmt.Fprintf(g.buf, "%s\t}\n", pre)
	}()

	if f.Tag != nil {
		if f.Tag.Refer != nil {
			fmt.Fprintf(g.buf, "%s\tif err := ele.decodeFromBuffer(buf); err != nil {\n", pre)
			return
		}
	}

	fmt.Fprintf(g.buf, "%s\tif err := binary.Read(buf, binary.LittleEndian, &%s.%s); err != nil {\n", pre, r, f.Name)
}

func (g *generator) structDecodeGenerate(st *Struct) {
	r := strings.ToLower(string(st.Name[0]))

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)Decode(payload []byte) error {\n", r, st.Name)
	fmt.Fprintf(g.buf, "\tbuf := bytes.NewBuffer(payload)\n")
	fmt.Fprintf(g.buf, "\treturn %s.decodeFromBuffer(buf)\n", r)
	fmt.Fprintf(g.buf, "}\n")

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)decodeFromBuffer(buf *bytes.Buffer) error {\n", r, st.Name)

	for _, f := range st.Fields {
		if f.Tag != nil {
			if f.Tag.Repeat != nil {
				fmt.Fprintf(g.buf, "\tfor i := 0; i < int(%s.%s); i++ {\n", r, *f.Tag.Repeat)
				fmt.Fprintf(g.buf, "\t\tvar ele %s\n", f.DataType[2:])
				g.filedDecodeGenerate(f, r, "\t")
				fmt.Fprintf(g.buf, "\t\t%s.%s = append(%s.%s, ele)\n", r, f.Name, r, f.Name)
				fmt.Fprintf(g.buf, "\t}\n")
				continue
			}
		}
		g.filedDecodeGenerate(f, r, "")
	}

	fmt.Fprintf(g.buf, "\n\treturn nil\n")
	fmt.Fprintf(g.buf, "}\n")
}

// Generate a file and accessor methods in it.
func Generate(pkg *Package, typeName, output, receiverName string) error {
	g := generator{buf: new(bytes.Buffer)}

	fmt.Fprintf(g.buf, "// Code generated by vstruct; DO NOT EDIT.\n")
	fmt.Fprintf(g.buf, "\n")
	fmt.Fprintf(g.buf, "package %s\n", pkg.Name)
	fmt.Fprintf(g.buf, "\n")

	g.writeHeader()
	for _, file := range pkg.Files {
		for _, st := range file.Structs {
			if st.Name != typeName {
				continue
			}
			// 遍历结构体
			g.structEncodeGenerate(st)
			g.structDecodeGenerate(st)
		}
	}

	outputFile := g.outputFile(output, pkg.Name, typeName, pkg.Dir)

	return os.WriteFile(outputFile, g.buf.Bytes(), 0644)
}

func (g *generator) outputFile(output, pkgName, typeName, dir string) string {
	if output == "" {
		// Use snake_case name of type as output file if output file is not specified.
		// type TestStruct will be test_struct_accessor.go
		var firstCapMatcher = regexp.MustCompile("(.)([A-Z][a-z]+)")
		var articleCapMatcher = regexp.MustCompile("([a-z0-9])([A-Z])")

		name := firstCapMatcher.ReplaceAllString(typeName, "${1}_${2}")
		name = articleCapMatcher.ReplaceAllString(name, "${1}_${2}")
		output = strings.ToLower(fmt.Sprintf("%s_%s_vstruct.go", pkgName, name))
	}

	return filepath.Join(dir, output)
}
