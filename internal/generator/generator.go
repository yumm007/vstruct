package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/spf13/afero"

	"vstruct/internal/types"
)

type generator struct {
	buf *bytes.Buffer
}

func (g *generator) writeHeader() {
	fmt.Fprintf(g.buf, "import (\n")
	fmt.Fprintf(g.buf, "\t\"bytes\"\n")
	fmt.Fprintf(g.buf, "\t\"encoding/binary\"\n")
	fmt.Fprintf(g.buf, ")\n\n")
}

func (g *generator) structEncodeGenerate(st *types.Struct) {
	receiver := strings.ToLower(string(st.Name[0]))

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)Encode() ([]byte, error) {\n", receiver, st.Name)
	fmt.Fprintf(g.buf, "\tbuf := new(bytes.Buffer)\n")
	fmt.Fprintf(g.buf, "\treturn %s.encodeToBuffer(buf)\n", receiver)
	fmt.Fprintf(g.buf, "}\n")

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)encodeToBuffer(buf *bytes.Buffer) ([]byte, error) {\n", receiver, st.Name)

	for _, f := range st.Fields {
		if f.Tag != nil {
			if f.Tag.Repeat != nil {
				fmt.Fprintf(g.buf, "\tfor i := 0; i < int(%s.%s); i++ {\n", receiver, *f.Tag.Repeat)
				fmt.Fprintf(g.buf, "\t\tif err := binary.Write(buf, binary.LittleEndian, %s.%s[i]); err != nil {\n", receiver, f.Name)
				fmt.Fprintf(g.buf, "\t\t\treturn nil, err\n")
				fmt.Fprintf(g.buf, "\t\t}\n")
				fmt.Fprintf(g.buf, "\t}\n")
			} else {
				fmt.Fprintf(g.buf, "\tif err := binary.Write(buf, binary.LittleEndian, %s.%s); err != nil {\n", receiver, f.Name)
				fmt.Fprintf(g.buf, "\t\treturn nil, err\n")
				fmt.Fprintf(g.buf, "\t}\n")
			}
		} else {
			fmt.Fprintf(g.buf, "\tif err := binary.Write(buf, binary.LittleEndian, %s.%s); err != nil {\n", receiver, f.Name)
			fmt.Fprintf(g.buf, "\t\treturn nil, err\n")
			fmt.Fprintf(g.buf, "\t}\n")
		}
	}

	fmt.Fprintf(g.buf, "\n\treturn buf.Bytes(), nil\n")
	fmt.Fprintf(g.buf, "}\n")
}

func (g *generator) structDecodeGenerate(st *types.Struct) {
	receiver := strings.ToLower(string(st.Name[0]))

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)Decode(payload []byte) error {\n", receiver, st.Name)
	fmt.Fprintf(g.buf, "\tbuf := bytes.NewBuffer(payload)\n")
	fmt.Fprintf(g.buf, "\treturn %s.decodeFromBuffer(buf, payload)\n", receiver)
	fmt.Fprintf(g.buf, "}\n")

	fmt.Fprintf(g.buf, "\nfunc (%s *%s)decodeFromBuffer(buf *bytes.Buffer, payload []byte) error {\n", receiver, st.Name)

	for _, f := range st.Fields {
		if f.Tag != nil {
			if f.Tag.Repeat != nil {
				fmt.Fprintf(g.buf, "\tfor i := 0; i < int(%s.%s); i++ {\n", receiver, *f.Tag.Repeat)
				fmt.Fprintf(g.buf, "\t\tvar ele %s\n", f.DataType[2:])
				fmt.Fprintf(g.buf, "\t\tif err := binary.Read(buf, binary.LittleEndian, &ele); err != nil {\n")
				fmt.Fprintf(g.buf, "\t\t\treturn err\n")
				fmt.Fprintf(g.buf, "\t\t}\n")
				fmt.Fprintf(g.buf, "\t\t%s.%s = append(%s.%s, ele)\n", receiver, f.Name, receiver, f.Name)
				fmt.Fprintf(g.buf, "\t}\n")
			} else {
				fmt.Fprintf(g.buf, "\tif err := binary.Read(buf, binary.LittleEndian, &%s.%s); err != nil {\n", receiver, f.Name)
				fmt.Fprintf(g.buf, "\t\treturn err\n")
				fmt.Fprintf(g.buf, "\t}\n")
			}
		} else {
			fmt.Fprintf(g.buf, "\tif err := binary.Read(buf, binary.LittleEndian, &%s.%s); err != nil {\n", receiver, f.Name)
			fmt.Fprintf(g.buf, "\t\treturn err\n")
			fmt.Fprintf(g.buf, "\t}\n")
		}
	}

	fmt.Fprintf(g.buf, "\n\treturn nil\n")
	fmt.Fprintf(g.buf, "}\n")
}

// Generate generates a file and accessor methods in it.
func Generate(fs afero.Fs, pkg *types.Package, typeName, output, receiverName string) error {
	g := generator{buf: new(bytes.Buffer)}

	g.printf("// Code generated by vstruct; DO NOT EDIT.\n")
	g.printf("\n")
	g.printf("package %s\n", pkg.Name)
	g.printf("\n")

	g.writeHeader()
	for _, file := range pkg.Files {
		for _, st := range file.Structs {
			if st.Name != typeName {
				continue
			}
			// 遍历结构体
			g.structEncodeGenerate(st)
			g.structDecodeGenerate(st)
		}
	}

	outputFile := g.outputFile(output, pkg.Name, typeName, pkg.Dir)

	return afero.WriteFile(fs, outputFile, g.buf.Bytes(), 0644)
}

func (g *generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(g.buf, format, args...)
}

func (g *generator) getterGenerator(
	receiverName string,
) func(structName string, field *types.Field) (string, error) {
	var tpl string

	tpl = `
			func ({{.Receiver}} *{{.Struct}}) {{.MethodName}}() {{.Type}} {
				return {{.Receiver}}.{{.Field}}
			}`

	t := template.Must(template.New("getter").Parse(tpl))

	return func(structName string, field *types.Field) (string, error) {
		methodName := *field.Tag.Repeat
		if methodName == "" {
			methodName = strings.Title(field.Name)
		}

		m := map[string]string{
			"Receiver":   g.receiverName(receiverName, structName),
			"Struct":     structName,
			"MethodName": methodName,
			"Field":      field.Name,
			"Type":       field.DataType,
		}

		buf := new(bytes.Buffer)
		err := t.Execute(buf, m)
		if err != nil {
			return "", err
		}

		return buf.String(), nil
	}
}

func (g *generator) receiverName(userInput string, structName string) string {
	if userInput != "" {
		// Do nothing if receiver name specified in args.
		return userInput
	}

	// Use the first letter of struct as receiver if receiver name is not specified.
	return strings.ToLower(string(structName[0]))
}

func (g *generator) outputFile(output, pkgName, typeName, dir string) string {
	if output == "" {
		// Use snake_case name of type as output file if output file is not specified.
		// type TestStruct will be test_struct_accessor.go
		var firstCapMatcher = regexp.MustCompile("(.)([A-Z][a-z]+)")
		var articleCapMatcher = regexp.MustCompile("([a-z0-9])([A-Z])")

		name := firstCapMatcher.ReplaceAllString(typeName, "${1}_${2}")
		name = articleCapMatcher.ReplaceAllString(name, "${1}_${2}")
		output = strings.ToLower(fmt.Sprintf("%s_%s_vstruct.go", pkgName, name))
	}

	return filepath.Join(dir, output)
}

func (g *generator) format() ([]byte, error) {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		return g.buf.Bytes(), err
	}
	return src, nil
}
