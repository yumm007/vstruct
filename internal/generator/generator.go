package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/spf13/afero"

	"vstruct/internal/types"
)

type generator struct {
	buf *bytes.Buffer
}

func (g *generator) structEncodeGenerate(st *types.Struct) {
	receiver := strings.ToLower(string(st.Name[0]))

	fmt.Fprintf(g.buf, "import (\n")
	fmt.Fprintf(g.buf, "\t\"bytes\"\n")
	fmt.Fprintf(g.buf, "\t\"encoding/binary\"\n")
	fmt.Fprintf(g.buf, ")\n\n")
	fmt.Fprintf(g.buf, "func (%s *%s)%sEncode() ([]byte, error) {\n", receiver, st.Name, st.Name)
	fmt.Fprintf(g.buf, "\tbuf := new(bytes.Buffer)\n\n")

	for _, f := range st.Fields {
		fmt.Fprintf(g.buf, "\tif err := binary.Write(buf, binary.LittleEndian, %s.%s); err != nil {\n", receiver, f.Name)
		fmt.Fprintf(g.buf, "\t\treturn nil, err\n")
		fmt.Fprintf(g.buf, "\t}\n")
	}

	fmt.Fprintf(g.buf, "\n\treturn buf.Bytes(), nil\n")
	fmt.Fprintf(g.buf, "}")
}

// Generate generates a file and accessor methods in it.
func Generate(fs afero.Fs, pkg *types.Package, typeName, output, receiverName string) error {
	g := generator{buf: new(bytes.Buffer)}

	g.printf("// Code generated by vstruct; DO NOT EDIT.\n")
	g.printf("\n")
	g.printf("package %s\n", pkg.Name)
	g.printf("\n")

	for _, file := range pkg.Files {
		for _, st := range file.Structs {
			if st.Name != typeName {
				continue
			}
			// 遍历结构体
			g.structEncodeGenerate(st)
		}
	}

	outputFile := g.outputFile(output, pkg.Name, pkg.Dir)

	return afero.WriteFile(fs, outputFile, g.buf.Bytes(), 0644)
}

func (g *generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(g.buf, format, args...)
}

func (g *generator) getterGenerator(
	receiverName string,
) func(structName string, field *types.Field) (string, error) {
	var tpl string

	tpl = `
			func ({{.Receiver}} *{{.Struct}}) {{.MethodName}}() {{.Type}} {
				return {{.Receiver}}.{{.Field}}
			}`

	t := template.Must(template.New("getter").Parse(tpl))

	return func(structName string, field *types.Field) (string, error) {
		methodName := *field.Tag.Repeat
		if methodName == "" {
			methodName = strings.Title(field.Name)
		}

		m := map[string]string{
			"Receiver":   g.receiverName(receiverName, structName),
			"Struct":     structName,
			"MethodName": methodName,
			"Field":      field.Name,
			"Type":       field.DataType,
		}

		buf := new(bytes.Buffer)
		err := t.Execute(buf, m)
		if err != nil {
			return "", err
		}

		return buf.String(), nil
	}
}

func (g *generator) receiverName(userInput string, structName string) string {
	if userInput != "" {
		// Do nothing if receiver name specified in args.
		return userInput
	}

	// Use the first letter of struct as receiver if receiver name is not specified.
	return strings.ToLower(string(structName[0]))
}

func (g *generator) outputFile(output, typeName, dir string) string {
	if output == "" {
		// Use snake_case name of type as output file if output file is not specified.
		// type TestStruct will be test_struct_accessor.go
		var firstCapMatcher = regexp.MustCompile("(.)([A-Z][a-z]+)")
		var articleCapMatcher = regexp.MustCompile("([a-z0-9])([A-Z])")

		name := firstCapMatcher.ReplaceAllString(typeName, "${1}_${2}")
		name = articleCapMatcher.ReplaceAllString(name, "${1}_${2}")
		output = strings.ToLower(fmt.Sprintf("%s_vstruct.go", name))
	}

	return filepath.Join(dir, output)
}

func (g *generator) format() ([]byte, error) {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		return g.buf.Bytes(), err
	}
	return src, nil
}
